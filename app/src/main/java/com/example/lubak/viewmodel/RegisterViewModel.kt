package com.example.lubak.viewmodel

import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lubak.api.RetrofitClient

import com.example.lubak.model.RegisterResponse
import com.example.lubak.model.UploadResponse
import com.example.lubak.model.User
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import java.time.LocalDateTime

class RegisterViewModel : ViewModel() {

    var email by mutableStateOf("")
    var username by mutableStateOf("")
    var firstName by mutableStateOf("")
    var lastName by mutableStateOf("")
    var password by mutableStateOf("")
    var confirmPassword by mutableStateOf("")
    var passwordVisible by mutableStateOf(false)
    private val apiService = RetrofitClient.instance
    var registrationResult by mutableStateOf<RegisterResponse?>(null)
    var isLoading by mutableStateOf(false)
    var emailError by mutableStateOf<String?>(null)
    var usernameError by mutableStateOf<String?>(null)
    var firstNameError by mutableStateOf<String?>(null)
    var lastNameError by mutableStateOf<String?>(null)
    var passwordError by mutableStateOf<String?>(null)
    var confirmPasswordError by mutableStateOf<String?>(null)

    fun onEmailChange(newEmail: String) {
        email = newEmail
    }

    fun onUsernameChange(newUsername: String) {
        username = newUsername
    }

    fun onFirstNameChange(newFirstName: String) {
        firstName = newFirstName
    }

    fun onLastNameChange(newLastName: String) {
        lastName = newLastName
    }

    fun onPasswordChange(newPassword: String) {
        password = newPassword
    }

    fun onConfirmPasswordChange(newConfirmPassword: String) {
        confirmPassword = newConfirmPassword
    }

    fun onPasswordVisibilityToggle() {
        passwordVisible = !passwordVisible
    }

//    @RequiresApi(Build.VERSION_CODES.O)
//    fun register(callback: (RegisterResponse) -> Unit) {
//        // Start loading state
//        isLoading = true
//
//        // Create the User object from the current state
//        val user = User(
//            id = 0, // Assuming the ID is generated by the server
//            email = email,
//            password = password,
//            userName = username,
//            firstName = firstName,
//            lastName = lastName,
//            createdAt = null // Automatically sets to the current time
//        )
//
//        viewModelScope.launch {
//            try {
//                // Make the network request in the IO thread
//                val response = withContext(Dispatchers.IO) {
//                    apiService.registerUser(user).execute()
//                }
//
//                // Handle the response
//                if (response.isSuccessful) {
//                    val result = RegisterResponse(success = true, message = "User registered successfully.")
//                    Log.d("RegisterViewModel", "Registration successful: ${response.body()}")
//                    callback(result)
//
//                } else {
//                    val result = RegisterResponse(success = false, message = "Registration failed with code: ${response.code()}")
//                    Log.e("RegisterViewModel", "Registration failed: ${response.errorBody()?.string()}")
//                    callback(result)
//
//                }
//            } catch (e: Exception) {
//                val result = RegisterResponse(success = false, message = "Error registering user: ${e.message}")
//                Log.e("RegisterViewModel", "Exception during registration", e)
//                callback(result)
//
//            } finally {
//                // Stop loading state
//                isLoading = false
//            }
//        }
//    }

    fun validateFields(): Boolean {
        var isValid = true
        emailError = if (email.isBlank()) "Email is required" else null
        usernameError = if (username.isBlank()) "Username is required" else null
        firstNameError = if (firstName.isBlank()) "First name is required" else null
        lastNameError = if (lastName.isBlank()) "Last name is required" else null
        passwordError = if (password.isBlank()) "Password is required" else null
        confirmPasswordError = when {
            confirmPassword.isBlank() -> "Confirm password is required"
            confirmPassword != password -> "Passwords do not match"
            else -> null
        }

        isValid = emailError == null && usernameError == null && firstNameError == null &&
                lastNameError == null && passwordError == null && confirmPasswordError == null

        return isValid
    }

    fun register(callback: (RegisterResponse) -> Unit) {
        isLoading = true

        // Create the User object from the current state
        val user = User(
            id = 0, // Assuming the ID is generated by the server
            email = email,
            password = password,
            userName = username,
            firstName = firstName,
            lastName = lastName,
            createdAt = null // Automatically sets to the current time
        )

        try {
            val call = apiService.registerUser(user)
            call.enqueue(object : Callback<RegisterResponse> {
                override fun onResponse(
                    call: Call<RegisterResponse>,
                    response: Response<RegisterResponse>
                ) {
                    isLoading = false
                    if (response.isSuccessful) {
                        response.body()?.let {
                            Log.d("Successful Response", "$it")
                            callback(it)
                        } ?: run {
                            Log.e("RegisterViewModel", "Response body is null")
                            callback(RegisterResponse(false, "Unexpected error"))
                        }
                    } else {
                        Log.e("Failed Response", "Error: ${response.code()} ${response.message()}")
                        callback(RegisterResponse(false, "Error registering user"))
                    }
                }

                override fun onFailure(call: Call<RegisterResponse>, t: Throwable) {
                    isLoading = false
                    Log.e("RegisterViewModel", "Error during registration", t)
                    callback(RegisterResponse(false, "Error during registration"))
                }
            })
        } catch (e: Exception) {
            isLoading = false
            Log.e("RegisterViewModel", "Exception during registration", e)
            callback(RegisterResponse(false, "Exception during registration"))
        }
    }}

