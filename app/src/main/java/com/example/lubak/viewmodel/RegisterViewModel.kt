package com.example.lubak.viewmodel

import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import com.example.lubak.api.RetrofitClient
import com.example.lubak.model.RegisterResponse
import com.example.lubak.model.User
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class RegisterViewModel : ViewModel() {

    var email by mutableStateOf("")
    var username by mutableStateOf("")
    var firstName by mutableStateOf("")
    var lastName by mutableStateOf("")
    var password by mutableStateOf("")
    var confirmPassword by mutableStateOf("")
    var passwordVisible by mutableStateOf(false)
    private val apiService = RetrofitClient.instance
    var registrationResult by mutableStateOf<RegisterResponse?>(null)
    var isLoading by mutableStateOf(false)
    var emailError by mutableStateOf<String?>(null)
    var usernameError by mutableStateOf<String?>(null)
    var firstNameError by mutableStateOf<String?>(null)
    var lastNameError by mutableStateOf<String?>(null)
    var passwordError by mutableStateOf<String?>(null)
    var confirmPasswordError by mutableStateOf<String?>(null)
    var passwordLengthError by mutableStateOf<Boolean?>(null)
    var passwordDigitError by mutableStateOf<Boolean?>(null)
    var passwordSpecialCharacterError by mutableStateOf<Boolean?>(null)
    var passwordUppercaseError by mutableStateOf<Boolean?>(null)

    fun onEmailChange(newEmail: String) {
        email = newEmail
    }

    fun onUsernameChange(newUsername: String) {
        username = newUsername
    }

    fun onFirstNameChange(newFirstName: String) {
        firstName = newFirstName
    }

    fun onLastNameChange(newLastName: String) {
        lastName = newLastName
    }

    fun onPasswordChange(newPassword: String) {
        password = newPassword

        passwordLengthError = hasAtLeast8Characters(newPassword)
        passwordDigitError = hasAtLeastOneDigit(newPassword)
        passwordSpecialCharacterError = hasAtLeastOneSpecialCharacter(newPassword)
        passwordUppercaseError = hasAtLeastOneUppercase(newPassword)


    }


    fun onConfirmPasswordChange(newConfirmPassword: String) {
        confirmPassword = newConfirmPassword
    }

    fun onPasswordVisibilityToggle() {
        passwordVisible = !passwordVisible
    }

    //    @RequiresApi(Build.VERSION_CODES.O)
//    fun register(callback: (RegisterResponse) -> Unit) {
//        // Start loading state
//        isLoading = true
//
//        // Create the User object from the current state
//        val user = User(
//            id = 0, // Assuming the ID is generated by the server
//            email = email,
//            password = password,
//            userName = username,
//            firstName = firstName,
//            lastName = lastName,
//            createdAt = null // Automatically sets to the current time
//        )
//
//        viewModelScope.launch {
//            try {
//                // Make the network request in the IO thread
//                val response = withContext(Dispatchers.IO) {
//                    apiService.registerUser(user).execute()
//                }
//
//                // Handle the response
//                if (response.isSuccessful) {
//                    val result = RegisterResponse(success = true, message = "User registered successfully.")
//                    Log.d("RegisterViewModel", "Registration successful: ${response.body()}")
//                    callback(result)
//
//                } else {
//                    val result = RegisterResponse(success = false, message = "Registration failed with code: ${response.code()}")
//                    Log.e("RegisterViewModel", "Registration failed: ${response.errorBody()?.string()}")
//                    callback(result)
//
//                }
//            } catch (e: Exception) {
//                val result = RegisterResponse(success = false, message = "Error registering user: ${e.message}")
//                Log.e("RegisterViewModel", "Exception during registration", e)
//                callback(result)
//
//            } finally {
//                // Stop loading state
//                isLoading = false
//            }
//        }
//    }
    private fun isValidEmail(email: String): Boolean {
        val emailRegex = "^[A-Za-z](.*)([@]{1})(.{1,})(\\.)(.{1,})$"
        return email.matches(emailRegex.toRegex())
    }

    private fun hasAtLeast8Characters(password: String): Boolean {
        val lengthRegex = ".{8,}"
        return password.matches(lengthRegex.toRegex())
    }

    private fun hasAtLeastOneDigit(password: String): Boolean {
        val digitRegex = ".*[0-9].*"
        return password.matches(digitRegex.toRegex())
    }

    private fun hasAtLeastOneSpecialCharacter(password: String): Boolean {
        val specialCharRegex = ".*[@#\$%^&+=!].*"
        return password.matches(specialCharRegex.toRegex())
    }

    private fun hasAtLeastOneUppercase(password: String): Boolean {
        val uppercaseRegex = ".*[A-Z].*"
        return password.matches(uppercaseRegex.toRegex())
    }


    fun validateFields(): Boolean {
        var isValid = true
        emailError = if (email.isBlank() || isValidEmail(email)) "Email is invalid" else null
        usernameError = if (username.isBlank()) "Username is required" else null
        firstNameError = if (firstName.isBlank()) "First name is required" else null
        lastNameError = if (lastName.isBlank()) "Last name is required" else null
        passwordError = if (password.isBlank()) "Password is required" else null
        confirmPasswordError = when {
            confirmPassword.isBlank() -> "Confirm password is required"
            confirmPassword != password -> "Passwords do not match"
            else -> null
        }
        passwordLengthError = hasAtLeast8Characters(password)
        passwordDigitError = hasAtLeastOneDigit(password)
        passwordSpecialCharacterError = hasAtLeastOneSpecialCharacter(password)
        passwordUppercaseError = hasAtLeastOneUppercase(password)

        isValid = emailError == null && usernameError == null && firstNameError == null &&
                lastNameError == null && passwordError == null && confirmPasswordError == null
                && passwordLengthError == true && passwordDigitError == true && passwordUppercaseError == true &&
                passwordUppercaseError == true

        return isValid
    }

    fun register(callback: (RegisterResponse) -> Unit) {
        isLoading = true

        // Create the User object from the current state
        val user = User(
            id = 0, // Assuming the ID is generated by the server
            email = email,
            password = password,
            userName = username,
            firstName = firstName,
            lastName = lastName,
            createdAt = null // Automatically sets to the current time
        )

        try {
            val call = apiService.registerUser(user)
            call.enqueue(object : Callback<RegisterResponse> {
                override fun onResponse(
                    call: Call<RegisterResponse>,
                    response: Response<RegisterResponse>
                ) {
                    isLoading = false
                    if (response.isSuccessful) {
                        response.body()?.let {
                            Log.d("Successful Response", "$it")
                            callback(it)
                        } ?: run {
                            Log.e("RegisterViewModel", "Response body is null")
                            callback(RegisterResponse(false, "Unexpected error"))
                        }
                    } else {
                        Log.e("Failed Response", "Error: ${response.code()} ${response.message()}")
                        callback(RegisterResponse(false, "Error registering user"))
                    }
                }

                override fun onFailure(call: Call<RegisterResponse>, t: Throwable) {
                    isLoading = false
                    Log.e("RegisterViewModel", "Error during registration", t)
                    callback(RegisterResponse(false, "Error during registration"))
                }
            })
        } catch (e: Exception) {
            isLoading = false
            Log.e("RegisterViewModel", "Exception during registration", e)
            callback(RegisterResponse(false, "Exception during registration"))
        }
    }
}

